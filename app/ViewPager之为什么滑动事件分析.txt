了解ViewPager的滑动切换界面原理,先从几个重要的方法下手,
onInterceptionTouchEvent : 解决了viewpager中嵌套listView 滑动的问题
1.先了解类Scroller:
   (1) computeScrollOffset():
        注释: 当返回true时候,表明该动作 还没做完成,动画还在继续绘制中
        这个方法主要针对两种滑动方式的位置进行设置:SCROLL_MODE,FLING_MODE.
        拿SCROLL_MODE举例:
           case SCROLL_MODE:
                           final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);
                           mCurrX = mStartX + Math.round(x * mDeltaX);
                           mCurrY = mStartY + Math.round(x * mDeltaY);
                           break;
        最后mCurrX,mCurrY 让我们直到当前在哪个位置.

   (2) abortAnimation():mCurrX = mFinalX,mCurrY = mFinalY,mFinished = true;
2.ViewPager:
            setScrollState(int newState) {
                if (mScrollState == newState) {
                    return;
                }
                mScrollState = newState;
                if (mPageTransformer != null) {
                    // PageTransformers can do complex things that benefit from hardware layers.
                    enableLayers(newState != SCROLL_STATE_IDLE);
                }
                if (mOnPageChangeListener != null) {
                    mOnPageChangeListener.onPageScrollStateChanged(newState);
                }
            }
onPageScrollStateChanged(state)只有在这个方法中才有调用.

            populate(int newCurrentItem){}

static class ItemInfo{
   Object mObject;
   int position;
   boolean scrolling;
   float widthFactor;
   float offset;
}

//这个方法只会在populate()这个方法中调用.
ItemInfo addNewItem(int position,int index){
   ItemInfo ii = new ItemInfo();
   ii.position = position;
   ii.object = mAdapter.instantiateItem(this,position);
   ii.widthFactor = mAdapter.getPageWidth(position);//这是百分比
   if (index < 0 || index >= mItems.size()) {
               mItems.add(ii);
   } else {
       mItems.add(index, ii);
   }
   return ii;
}

public boolean canScrollHorizontally(int direction) {
        if (mAdapter == null) {
            return false;
        }

        final int width = getClientWidth();//getMeasuredWidth() - getPaddingLeft() - getPaddingRight();
        final int scrollX = getScrollX();
        if (direction < 0) {
            return (scrollX > (int) (width * mFirstOffset));
        } else if (direction > 0) {
            return (scrollX < (int) (width * mLastOffset));
        } else {
            return false;
        }
    }

填充view,可以理解为在显示当前item时候,会在缓存列表中缓存至少一个左右item,至少是多少,我们可以自己设置,离显示item的偏移量
void populate(int newCurrentItem) {
        ItemInfo oldCurInfo = null;
        int focusDirection = View.FOCUS_FORWARD;
        if (mCurItem != newCurrentItem) {
            focusDirection = mCurItem < newCurrentItem ? View.FOCUS_RIGHT : View.FOCUS_LEFT;
            //找到旧item,方便计算当前item 跟 oldItem的偏移量
            oldCurInfo = infoForPosition(mCurItem);
            mCurItem = newCurrentItem;
        }

        if (mAdapter == null) {
            //缓存所有child,然后按一定的优先级排列
            sortChildDrawingOrder();
            return;
        }

        // Bail now if we are waiting to populate.  This is to hold off
        // on creating views from the time the user releases their finger to
        // fling to a new position until we have finished the scroll to
        // that position, avoiding glitches from happening at that point.
        if (mPopulatePending) {
            if (DEBUG) Log.i(TAG, "populate is pending, skipping for now...");
            sortChildDrawingOrder();
            return;
        }

        // Also, don't populate until we are attached to a window.  This is to
        // avoid trying to populate before we have restored our view hierarchy
        // state and conflicting with what is restored.
        if (getWindowToken() == null) {
            return;
        }

        //数据要发生变化,要开始更新了
        mAdapter.startUpdate(this);

        final int pageLimit = mOffscreenPageLimit;//默认是1,
        final int startPos = Math.max(0, mCurItem - pageLimit);
        final int N = mAdapter.getCount();
        final int endPos = Math.min(N-1, mCurItem + pageLimit);

        //假设adapter.getCount发生了变化,抛出异常.
        if (N != mExpectedAdapterCount) {
            String resName;
            try {
                resName = getResources().getResourceName(getId());
            } catch (Resources.NotFoundException e) {
                resName = Integer.toHexString(getId());
            }
            throw new IllegalStateException("The application's PagerAdapter changed the adapter's" +
                    " contents without calling PagerAdapter#notifyDataSetChanged!" +
                    " Expected adapter item count: " + mExpectedAdapterCount + ", found: " + N +
                    " Pager id: " + resName +
                    " Pager class: " + getClass() +
                    " Problematic adapter: " + mAdapter.getClass());
        }

        // Locate the currently focused item or add it if needed.
        // 找到currItem在缓存列表中的排列的位置.
        int curIndex = -1;
        ItemInfo curItem = null;
        for (curIndex = 0; curIndex < mItems.size(); curIndex++) {
            final ItemInfo ii = mItems.get(curIndex);
            if (ii.position >= mCurItem) {
                if (ii.position == mCurItem) curItem = ii;
                break;
            }
        }
        //若在缓存列表中找不到这个currItem,添加一个,addNewItem主要调用mAdapter.instantiateItem(),
        //而这个方法也是我们PageAdapter,FragmentAdapter,FragmentStateAdapter要有相对应的处理逻辑
        //这样我们取到当前currItem 在当前缓存列表中的位置 curIndex.
        if (curItem == null && N > 0) {
            curItem = addNewItem(mCurItem, curIndex);//保证了在mItems.size()中位置curIndex 就是curItem,
        }


        // 接下来整个缓存列表的核心,就是说ViewPager是怎么做到在滑动时候左右两边是加载好的
        // 拿左侧举例,默认先缓存一个左侧的嘛,那么就要确保当前curItem 在缓存列表的前一个也是
        // 左侧的那一个,接下来删掉离curItem 偏移量较远的item, 怎样才是偏移量较远的呢,我们可以
        // 自己定义,  if (extraWidthLeft >= leftWidthNeeded && pos < startPos)
        // leftWithNeeded = 1, 所以我们偏移量 >=1 , 考虑一种特殊情况 curItem.position = 0;
        // 那么就左侧是没有删的了.
        // 右侧也是一样.
        // 最后,还有一个重要的工作,计算离curItem的偏移量,只要在缓存列表中的item都要计算偏移量.



        // Fill 3x the available width or up to the number of offscreen
        // pages requested to either side, whichever is larger.
        // If we have no current item we have no work to do.
        if (curItem != null) {
            float extraWidthLeft = 0.f;
            int itemIndex = curIndex - 1;
            ItemInfo ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;
            final int clientWidth = getClientWidth();
            final float leftWidthNeeded = clientWidth <= 0 ? 0 :
                    2.f - curItem.widthFactor + (float) getPaddingLeft() / (float) clientWidth;
            for (int pos = mCurItem - 1; pos >= 0; pos--) {
                if (extraWidthLeft >= leftWidthNeeded && pos < startPos) {
                    if (ii == null) {
                        break;
                    }
                    if (pos == ii.position && !ii.scrolling) {
                        mItems.remove(itemIndex);
                        mAdapter.destroyItem(this, pos, ii.object);
                        if (DEBUG) {
                            Log.i(TAG, "populate() - destroyItem() with pos: " + pos +
                                    " view: " + ((View) ii.object));
                        }
                        itemIndex--;
                        curIndex--;
                        ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;
                    }
                } else if (ii != null && pos == ii.position) {
                    extraWidthLeft += ii.widthFactor;
                    itemIndex--;
                    ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;
                } else {
                    ii = addNewItem(pos, itemIndex + 1);
                    extraWidthLeft += ii.widthFactor;
                    curIndex++;
                    ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;
                }
            }

            float extraWidthRight = curItem.widthFactor;
            itemIndex = curIndex + 1;
            if (extraWidthRight < 2.f) {
                ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;
                final float rightWidthNeeded = clientWidth <= 0 ? 0 :
                        (float) getPaddingRight() / (float) clientWidth + 2.f;
                for (int pos = mCurItem + 1; pos < N; pos++) {
                    if (extraWidthRight >= rightWidthNeeded && pos > endPos) {
                        if (ii == null) {
                            break;
                        }
                        if (pos == ii.position && !ii.scrolling) {
                            mItems.remove(itemIndex);
                            mAdapter.destroyItem(this, pos, ii.object);
                            if (DEBUG) {
                                Log.i(TAG, "populate() - destroyItem() with pos: " + pos +
                                        " view: " + ((View) ii.object));
                            }
                            ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;
                        }
                    } else if (ii != null && pos == ii.position) {
                        extraWidthRight += ii.widthFactor;
                        itemIndex++;
                        ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;
                    } else {
                        ii = addNewItem(pos, itemIndex);
                        itemIndex++;
                        extraWidthRight += ii.widthFactor;
                        ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;
                    }
                }
            }

            calculatePageOffsets(curItem, curIndex, oldCurInfo);
        }

        if (DEBUG) {
            Log.i(TAG, "Current page list:");
            for (int i=0; i<mItems.size(); i++) {
                Log.i(TAG, "#" + i + ": page " + mItems.get(i).position);
            }
        }


        // primary : 主要的,就是我们当前curItem,所以我们要实现一些特殊的功能,首先要
        // super.setPrimaryItem();
        mAdapter.setPrimaryItem(this, mCurItem, curItem != null ? curItem.object : null);


        // 表示所有child的操作都已经完成.
        mAdapter.finishUpdate(this);

        // Check width measurement of current pages and drawing sort order.
        // Update LayoutParams as needed.
        final int childCount = getChildCount();
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            lp.childIndex = i;
            if (!lp.isDecor && lp.widthFactor == 0.f) {
                // 0 means requery the adapter for this, it doesn't have a valid width.
                final ItemInfo ii = infoForChild(child);
                if (ii != null) {
                    lp.widthFactor = ii.widthFactor;
                    lp.position = ii.position;
                }
            }
        }
        sortChildDrawingOrder();

        // 查看是否有 focus ,可能是viewPager本身,也可能是child
        // 若child有focus
        if (hasFocus()) {
            View currentFocused = findFocus();
            ItemInfo ii = currentFocused != null ? infoForAnyChild(currentFocused) : null;
            if (ii == null || ii.position != mCurItem) {
                for (int i=0; i<getChildCount(); i++) {
                    View child = getChildAt(i);
                    ii = infoForChild(child);
                    if (ii != null && ii.position == mCurItem) {
                        if (child.requestFocus(focusDirection)) {
                            break;
                        }
                    }
                }
            }
        }
    }


private void completeScroll(boolean postEvents) {
        boolean needPopulate = mScrollState == SCROLL_STATE_SETTLING;
        if (needPopulate) {
            // Done with scroll, no longer want to cache view drawing.
            setScrollingCacheEnabled(false);
            mScroller.abortAnimation();
            int oldX = getScrollX();
            int oldY = getScrollY();
            int x = mScroller.getCurrX();
            int y = mScroller.getCurrY();
            if (oldX != x || oldY != y) {
                scrollTo(x, y);
                if (x != oldX) {
                    pageScrolled(x);
                }
            }
        }
        mPopulatePending = false;
        for (int i=0; i<mItems.size(); i++) {
            ItemInfo ii = mItems.get(i);
            if (ii.scrolling) {
                needPopulate = true;
                ii.scrolling = false;
            }
        }
        if (needPopulate) {
            if (postEvents) {
                ViewCompat.postOnAnimation(this, mEndScrollRunnable);
            } else {
                mEndScrollRunnable.run();
            }
        }
    }

private boolean pageScrolled(int xpos) {
        if (mItems.size() == 0) {
            mCalledSuper = false;
            onPageScrolled(0, 0, 0);
            if (!mCalledSuper) {
                throw new IllegalStateException(
                        "onPageScrolled did not call superclass implementation");
            }
            return false;
        }
        final ItemInfo ii = infoForCurrentScrollPosition();
        final int width = getClientWidth();
        final int widthWithMargin = width + mPageMargin;
        final float marginOffset = (float) mPageMargin / width;
        final int currentPage = ii.position;
        //pageOffset = [-1,1]
        final float pageOffset = (((float) xpos / width) - ii.offset) /
                (ii.widthFactor + marginOffset);
        final int offsetPixels = (int) (pageOffset * widthWithMargin);

        mCalledSuper = false;
        onPageScrolled(currentPage, pageOffset, offsetPixels);
        if (!mCalledSuper) {
            throw new IllegalStateException(
                    "onPageScrolled did not call superclass implementation");
        }
        return true;
    }
